import numpy as np
import matplotlib.pyplot as plt

# Parámetros del circuito RLC subamortiguado
# Condición: R² < 4L/C para subamortiguado
L = 0.03    # Inductancia en Henries
C = 0.01    # Capacitancia en Faradios (10 miliFaradios)
R = 0.5     # Resistencia (debe cumplir R² < 4L/C para subamortiguado)
V0 = 10.0   # Voltaje inicial en el capacitor (Volts)
I0 = 0.0    # Corriente inicial en el inductor (Amperes)

# Calcular parámetros del circuito
alpha = R / (2 * L)  # Factor de amortiguación
omega0 = 1 / np.sqrt(L * C)  # Frecuencia natural no amortiguada
omega_d = np.sqrt(omega0**2 - alpha**2)  # Frecuencia natural amortiguada

# Verificar condición de subamortiguación
print("\n=== Verificación de Amortiguación ===")
print(f"R² = {R**2:.4f}")
print(f"4L/C = {4*L/C:.4f}")
if R**2 < 4*L/C:
    print("✓ Circuito subamortiguado (R² < 4L/C)")
else:
    print("⚠ ADVERTENCIA: El circuito NO está subamortiguado")
    print("   Para subamortiguado, R debe ser menor que", f"{np.sqrt(4*L/C):.4f} Ω")

# Calcular constantes A y B para voltaje en el capacitor
# Condiciones iniciales: v(0) = V0, dv/dt(0) = I0/C
# Para subamortiguado: v(t) = e^(-αt) * (A*cos(ωd*t) + B*sin(ωd*t))
A = V0
B = (I0/C + alpha * V0) / omega_d

# Tiempo
t = np.linspace(0, 0.5, 2000)  # 0 a 500 ms

# Respuesta subamortiguada: v(t) = e^(-αt) * (A*cos(ωd*t) + B*sin(ωd*t))
v_t = np.exp(-alpha * t) * (A * np.cos(omega_d * t) + B * np.sin(omega_d * t))

# Crear la gráfica
plt.figure(figsize=(12, 10))

# Gráfica principal del voltaje
plt.subplot(3, 1, 1)
plt.plot(t * 1000, v_t, 'b-', linewidth=2.5, label='Voltaje en el capacitor v(t)')
plt.xlabel('Tiempo (ms)', fontsize=12)
plt.ylabel('Voltaje (V)', fontsize=12)
plt.title('Respuesta de Circuito RLC Subamortiguado', fontsize=14, fontweight='bold')
plt.grid(True, alpha=0.3, linestyle='--')
plt.legend(fontsize=11)
plt.axhline(y=0, color='k', linestyle='-', linewidth=0.5)
plt.axvline(x=0, color='k', linestyle='-', linewidth=0.5)

# Calcular y graficar la corriente
# i(t) = C * dv/dt
# dv/dt = e^(-αt) * [-α*(A*cos(ωd*t) + B*sin(ωd*t)) + ωd*(-A*sin(ωd*t) + B*cos(ωd*t))]
dv_dt = np.exp(-alpha * t) * (-alpha * (A * np.cos(omega_d * t) + B * np.sin(omega_d * t)) + 
                               omega_d * (-A * np.sin(omega_d * t) + B * np.cos(omega_d * t)))
i_t = C * dv_dt

plt.subplot(3, 1, 2)
plt.plot(t * 1000, i_t, 'r-', linewidth=2.5, label='Corriente en el circuito i(t)')
plt.xlabel('Tiempo (ms)', fontsize=12)
plt.ylabel('Corriente (A)', fontsize=12)
plt.title('Corriente del Circuito RLC Subamortiguado', fontsize=12, fontweight='bold')
plt.grid(True, alpha=0.3, linestyle='--')
plt.legend(fontsize=11)
plt.axhline(y=0, color='k', linestyle='-', linewidth=0.5)

# Gráfica de la envolvente exponencial
envolvente_superior = np.exp(-alpha * t) * np.sqrt(A**2 + B**2)
envolvente_inferior = -envolvente_superior

plt.subplot(3, 1, 3)
plt.plot(t * 1000, v_t, 'b-', linewidth=2, label='Voltaje v(t)')
plt.plot(t * 1000, envolvente_superior, 'g--', linewidth=1.5, label='Envolvente superior')
plt.plot(t * 1000, envolvente_inferior, 'g--', linewidth=1.5, label='Envolvente inferior')
plt.xlabel('Tiempo (ms)', fontsize=12)
plt.ylabel('Voltaje (V)', fontsize=12)
plt.title('Respuesta con Envolvente Exponencial', fontsize=12)
plt.grid(True, alpha=0.3, linestyle='--')
plt.legend(fontsize=10)
plt.axhline(y=0, color='k', linestyle='-', linewidth=0.5)

plt.tight_layout()

# Mostrar información del circuito
print("\n=== Parámetros del Circuito RLC ===")
print(f"Resistencia (R): {R:.4f} Ω")
print(f"Inductancia (L): {L:.4f} H")
print(f"Capacitancia (C): {C*1000:.4f} mF")
print(f"\nFactor de amortiguación (α): {alpha:.4f} rad/s")
print(f"Frecuencia natural no amortiguada (ω₀): {omega0:.4f} rad/s")
print(f"Frecuencia natural amortiguada (ωd): {omega_d:.4f} rad/s")
print(f"Período de oscilación: {2*np.pi/omega_d*1000:.4f} ms")
print(f"\nCondición subamortiguada: R² < 4L/C ✓")
print(f"\nVoltaje inicial (V₀): {V0:.2f} V")
print(f"Corriente inicial (I₀): {I0:.2f} A")
print(f"\nConstantes de la solución:")
print(f"A = {A:.4f}")
print(f"B = {B:.4f}")
print(f"Amplitud inicial: {np.sqrt(A**2 + B**2):.4f} V")

# Calcular tiempo de establecimiento (tiempo para llegar al 2% del valor inicial)
t_2porciento = None
for i, v in enumerate(v_t):
    if abs(v) < 0.02 * abs(V0):
        t_2porciento = t[i] * 1000
        break

if t_2porciento:
    print(f"\nTiempo de establecimiento (2% del valor inicial): {t_2porciento:.2f} ms")

# Calcular factor de calidad Q
Q = omega0 * L / R
print(f"\nFactor de calidad (Q): {Q:.4f}")

plt.show()
